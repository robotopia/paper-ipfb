import sys
import numpy as np
import matplotlib.pyplot as plt

# Parameters for PFB
ntaps = 12
K = 128
N = ntaps*K
M = K  # meaning "ciritically sampled"

# Choose the analysis filter
def wH(n):
    return np.sin(np.pi*(n+1)/(N+1))**2

def ws(n):
    return np.sinc((n+1-N/2)/K)

def h(n):
    return wH(n)*ws(n)*np.logical_and(n >= 0, n < N)

# The mirror synthesis filter
def f(n):
    H = np.sum(h(ns))
    return h(-n)

# Find some other synthesis filters!
filter_types = ["Mirror", 12, 18, 24]
plottable = [0, 1, 2, 3] # The indices for which filters in "filter_types" should be plotted
SNR = np.zeros((len(filter_types), K))
fig, axs = plt.subplots(len(plottable), sharex=True, gridspec_kw={'hspace': 0}) # Plots for the filter coefficients

for a in range(len(filter_types)):

    filter_size = filter_types[a]

    if not isinstance(filter_size, int):
        Ftaps = ntaps
    else:
        Ftaps = filter_size

    Hsize = (Ftaps + ntaps - 1, Ftaps)
    Href = (Hsize[0] // 2, Hsize[1] // 2 - ntaps // 2)

    Fhat = np.zeros((Hsize[1], K))
    Dhat = np.zeros((Hsize[0], K))
    for n in range(K):
        # Try and find the inverse to the analysis filter, h(n)
        # Step 1: Create H array, e.g.,
        #          <----------------  Hsize[1] ----------------->
        #    ^     [ h(n+11*M)      0          0         ...    ]
        #    |     [ h(n+10*M)  h(n+11*M)      0         ...    ]
        #    |     [ h(n+ 9*M)  h(n+10*M)  h(n+11*M)     ...    ]
        # Hsize[0] [    ...        ...        ...        ...    ]
        #    |     [    ...     h(n+ 0*M)  h(n+ 1*M)  h(n+ 2*M) ]
        #    |     [    ...         0      h(n+ 0*M)  h(n+ 1*M) ]
        #    v     [    ...         0          0      h(n+ 0*M) ]
        H = np.zeros(Hsize)
        Mmat = np.zeros(Hsize)
        for i in range(Hsize[0]):
            for j in range(Hsize[1]):
                m = (j - i) - (Href[1] - Href[0])
                #Mmat[i,j] = m
                H[i,j] = h(n + m*M)

        # Now, we want to solve the matrix equation HF = D for F,
        # where D is the "Kronecker delta"
        D = np.zeros((Hsize[0], 1))
        D[(Hsize[0] + 1)//2 - 1] = 1

        if filter_size == "Mirror":
            Fhat[:,n] = [h(n + m*M) for m in range(Ftaps)] # Set synth filter = analysis filter
        elif filter_size == "fft":
            Fhat[:,n] = 1/Ftaps
        else:
            # H is non-square
            HT        = np.transpose(H)
            HTH       = np.matmul(HT, H)
            HTD       = np.matmul(HT, D)
            invHTH    = np.linalg.pinv(HTH)
            Fhat[:,n:n+1] = np.matmul(invHTH, HTD)

        # Let's see how well the solution does
        Dhat[:,n:n+1] = np.matmul(H, Fhat[:,n:n+1])

    F = Fhat.flatten()
    ns = np.arange(N)
    Fns = np.arange(F.size)

    # Plot figures
    # The plot for the filter coefficients
    if a in plottable:
        if filter_types[a] == "Mirror":
            label = "Mirror filter, {0} taps".format(Ftaps)
        else:
            label = "Least squares filter, {0} taps".format(filter_size)
        plot_no = plottable.index(a)
        axs[plot_no].plot(Fns - F.size//2, F, 'k-', label=label)
        axs[plot_no].legend()
        axs[plot_no].set_yticks([0,1])
        axs[plot_no].set_ylabel(" ")

    plt.figure("Performance overall")
    plt.clf()
    plt.imshow(Dhat, origin='lower', aspect='auto', cmap='bwr', extent=(-0.5, M+0.5, -(Hsize[0]+1)//2-0.5, (Hsize[0]+1)//2+0.5))
    cmax = np.max(np.abs(Dhat))
    plt.clim([-cmax, cmax])
    plt.colorbar(label="$\\sum_{m=0}^{M-1}\,f_m[n]\,h_m[sM-n] - \\delta_s^0$")
    plt.xlabel("$n$")
    plt.ylabel("$s$")
    plt.savefig("rinv_perf_{0}.png".format(filter_size))

    # Finally, calculate the relative S/N for each n
    SNR[a,:] = (Dhat[(Hsize[0] + 1)//2 - 1])**2 / np.sum(Dhat**2, axis=0)
    SNR[a,:] = 10*np.log10(SNR[a,:])

    # Write out the spectrum to rinv.txt
    header =  "Synthesis filter coefficients for the {0}-tap filter\n".format(filter_size)
    header += "Generated by\n"
    header += "python" + " ".join(sys.argv)
    np.savetxt("rinv_{0}.txt".format(filter_size), F, header=header)

    plt.figure("Reconstructed S/N")
    ms = np.arange(M)
    if isinstance(filter_size, int):
        label = "Least squares sol'n"
    elif filter_size == "Mirror":
        label = "Mirror filter"
    else:
        label = "(undefined)"
    label += ", {0} taps".format(Ftaps)
    plt.plot(ms, SNR[a,:], label=label)

plt.figure("Reconstructed S/N")
plt.xlabel("Position within tap, $n$")
plt.ylabel("Reconstructed S/N (dB)")
plt.ylim([-0.65,0.025])
plt.tight_layout()
plt.legend()
plt.savefig("snr.eps")

axs[-1].set_xlabel("Sample number, $n$")
fig.text(0.02, 0.5, 'Normalised filter coefficients', va='center', rotation='vertical')
fig.tight_layout()
fig.savefig("inverse_filters.eps")

'''
# Show figures
plt.legend()
plt.show()
'''
